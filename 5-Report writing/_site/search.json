[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Tables don’t have to be dull lists of numbers. If done correctly, they can, in fact, be beautiful & engaging. And in this book, we’re going to learn how to create such tables with R. More precisely, we will learn how to use the {gt} package.\n?@sec-getting-started is the starting point of our {gt} journey. It will cover useful guidelines for any table and how to implement them with {gt}. You can think of this chapter as a quickstart guide.\nAfterwards, we’re learning how to add eye-catching elements like plots, icons and images to our table in ?@sec-fancy-stuff. Many of these elements are powered through the amazing {gtExtras} package. But you will also learn how to add any plot to your table (regardless of whether it is implemented in {gtExtras} or not.)\nNext, we’ll talk about formatting the entries of your table in ?@sec-formatting. {gt} has two powerful sets of functions to get this job done, namely fmt_*() and sub_*(). These functions all work the same and are pretty easy to pick up. Hence, it’s easy to format the data in your table the way you want or need.\nIn ?@sec-styling, we’re learning how to change the theme of our table. This will be a long chapter. After all, we can basically change anything about our table’s appearance.\nAll of the knowledge that we’ve acquired in the previous chapters culminate in ?@sec-case-studies. That’s where we will build elaborate tables with {gt}.\nFinally, ?@sec-quarto is a special chapter dedicated to the interactions between Quarto and {gt}. As of right now (Quarto v1.2.267 & {gt} v0.8.0), Quarto’s default theme can interact with your {gt} table and change its theme. But there are ways to isolate Quarto from {gt}. This is what you’ll learn in this chapter.\n\n\nThis book is meant for people with an intermediate knowledge of R, specifically the Tidyverse. I do not expect people to know HTML/CSS for the most parts.\nThroughout most of the book, we’ll only to do small changes with HTML/CSS and these bits will be explained. But there will be parts in ?@sec-styling and the subsequent chapters that will talk about changing CSS styles. Feel free to skip these parts if you’re uncomfortable with CSS. But I’ll do my best to help you with CSS.\n\n\n\nThis book is completely free and the code is open-source.\n\n\n\nJust so you’re sure what versions I’m using. Here’s my session info and my Quarto version."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction",
    "section": "",
    "text": "This book is meant for people with an intermediate knowledge of R, specifically the Tidyverse. I do not expect people to know HTML/CSS for the most parts.\nThroughout most of the book, we’ll only to do small changes with HTML/CSS and these bits will be explained. But there will be parts in ?@sec-styling and the subsequent chapters that will talk about changing CSS styles. Feel free to skip these parts if you’re uncomfortable with CSS. But I’ll do my best to help you with CSS."
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Introduction",
    "section": "",
    "text": "This book is completely free and the code is open-source."
  },
  {
    "objectID": "index.html#session-info",
    "href": "index.html#session-info",
    "title": "Introduction",
    "section": "",
    "text": "Just so you’re sure what versions I’m using. Here’s my session info and my Quarto version."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Workshop",
    "section": "",
    "text": "Workshop series on R programming\n\nUnlock the power of data analysis and visualization with our comprehensive R Workshop! Join us to learn R programming, data manipulation, and visualization techniques. Discover how to effectively analyze data, create insightful visualizations, and gain valuable insights for your research. Our hands-on approach and expert instructors will guide you through practical exercises and real-world examples, ensuring you leave with practical skills to harness R’s capabilities.\n\nLocation: Department of Statistics, CUSAT\nResource: Dr. Rasin RS, Mahesh D & Rakesh Poduval"
  },
  {
    "objectID": "getting Start.html",
    "href": "getting Start.html",
    "title": "Overview",
    "section": "",
    "text": "The gt package is all about making it simple to produce nice-looking display tables. Display tables? Well yes, we are trying to distinguish between data tables (e.g., tibbles, data.frames, etc.) and those tables you’d find in a web page, a journal article, or in a magazine. Such tables can likewise be called presentation tables, summary tables, or just tables really. Here are some examples, ripped straight from the web:\n\nWe can think of display tables as output only, where we’d not want to use them as input ever again. Other features include annotations, table element styling, and text transformations that serve to communicate the subject matter more clearly.\n\nA Walkthrough of the gt Basics with a Simple Table\nLet’s use a less common dataset that is available in the R datasets package: islands. It’s actually not a data frame but a named vector. That’s okay though, we can use use dplyr and prepare a tibble from it:\n\n# Take the `islands` dataset and use some\n# dplyr functionality to obtain the ten\n# biggest islands in the world\nislands_tbl &lt;- \n  tibble(\n    name = names(islands),\n    size = islands\n  ) |&gt;\n  arrange(desc(size)) |&gt;\n  slice(1:10)\n\n# Display the table\nislands_tbl\n#&gt; # A tibble: 10 × 2\n#&gt;    name           size\n#&gt;    &lt;chr&gt;         &lt;dbl&gt;\n#&gt;  1 Asia          16988\n#&gt;  2 Africa        11506\n#&gt;  3 North America  9390\n#&gt;  4 South America  6795\n#&gt;  5 Antarctica     5500\n#&gt;  6 Europe         3745\n#&gt;  7 Australia      2968\n#&gt;  8 Greenland       840\n#&gt;  9 New Guinea      306\n#&gt; 10 Borneo          280\n\nGiven that islands_tbl is a tibble, we now have a suitable input for gt.\nThe main entry point into the gt API is the gt() function. If we pass islands_tbl to the function gt(), we’ll get a gt Table as output. As an aside, we could have easily used a data frame instead as valid Table Data for gt.\n\n# Create a display table showing ten of\n# the largest islands in the world\ngt_tbl &lt;- gt(islands_tbl)\n\n# Show the gt Table\ngt_tbl\n\n\n\n\n\n  \n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n  \n\n\n\n\nThat doesn’t look too bad. Sure, it’s basic but we really didn’t really ask for much. We did receive a proper table with column labels and the data. Also, that default striping is a nice touch. Oftentimes however, you’ll want a bit more: a Table header, a Stub, and sometimes footnotes and source notes in the Table Footer part.\n\n\nAdding Parts to this Simple Table\nThe gt package makes it relatively easy to add parts so that the resulting gt Table better conveys the information you want to present. These table parts work well together and there the possible variations in arrangement can handle most tabular presentation needs. The previous gt Table demonstrated had only two parts, the Column Labels and the Table Body. The next few examples will show all of the other table parts that are available.\nThis is the way the main parts of a table (and their subparts) fit together:\n\n\n\nThe parts (roughly from top to bottom) are:\n\nthe Table Header (optional; with a title and possibly a subtitle)\nthe Stub and the Stub Head (optional; contains row labels, optionally within row groups having row group labels and possibly summary labels when a summary is present)\nthe Column Labels (contains column labels, optionally under spanner column labels)\nthe Table Body (contains columns and rows of cells)\nthe Table Footer (optional; possibly with footnotes and source notes)\n\nThe way that we add parts like the Table Header and footnotes in the Table Footer is to use the tab_*() family of functions. A Table Header is easy to add so let’s see how the previous table looks with a title and a subtitle. We can add this part using the tab_header() function:\n\n# Make a display table with the `islands_tbl`\n# table; put a heading just above the column labels\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_header(\n    title = \"Large Landmasses of the World\",\n    subtitle = \"The top ten largest are presented\"\n  )\n\n# Show the gt Table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n  \n\n\n\n\nThe Header table part provides an opportunity to describe the data that’s presented. The subtitle, which functions as a subtitle, is an optional part of the Header. We may also style the title and subtitle using Markdown! We do this by wrapping the values passed to title or subtitle with the md() function. Here is an example with the table data truncated for brevity:\n\n# Use markdown for the heading's `title` and `subtitle` to\n# add bold and italicized characters\ngt(islands_tbl[1:2,]) |&gt;\n  tab_header(\n    title = md(\"**Large Landmasses of the World**\"),\n    subtitle = md(\"The *top two* largest are presented\")\n  )\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top two largest are presented\n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n  \n  \n  \n\n\n\n\nA source note can be added to the table’s footer through use of the tab_source_note() function. It works in the same way as tab_header() (it also allows for Markdown inputs) except it can be called multiple times—each invocation results in the addition of a source note.\n\n# Display the `islands_tbl` data with a heading and\n# two source notes\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_source_note(\n    source_note = \"Source: The World Almanac and Book of Facts, 1975, page 406.\"\n  ) |&gt;\n  tab_source_note(\n    source_note = md(\"Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.\")\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n    \n      Source: The World Almanac and Book of Facts, 1975, page 406.\n    \n    \n      Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n    \n  \n  \n\n\n\n\nFootnotes live inside the Footer part and their footnote marks are attached to cell data. Footnotes are added with the tab_footnote() function. The helper function cells_body() can be used with the location argument to specify which data cells should be the target of the footnote. The cells_body() helper has the two arguments columns and rows. For each of these, we can supply (1) a vector of colnames or rownames, (2) a vector of column/row indices, (3) bare column names wrapped in c() or row labels within c(), or (4) a select helper function (starts_with(), ends_with(), contains(), matches(), one_of(), and everything()). For rows specifically, we can use a conditional statement with column names as variables (e.g., size &gt; 15000).\nHere is a simple example on how a footnotes can be added to a table cell. Let’s add a footnote that references the North America and South America cells in the name column:\n\n# Add footnotes (the same text) to two different\n# cell; data cells are targeted with `data_cells()`\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_footnote(\n    footnote = \"The Americas.\",\n    locations = cells_body(columns = name, rows = 3:4)\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America1\n9390\n    South America1\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n    \n      Source: The World Almanac and Book of Facts, 1975, page 406.\n    \n    \n      Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n    \n  \n  \n    \n      1 The Americas.\n    \n  \n\n\n\n\nHere is a slightly more complex example of adding footnotes that use expressions in rows to help target cells in a column by the underlying data in islands_tbl. First, a set of dplyr statements obtains the name of the ‘island’ by largest landmass. This is assigned to the largest object and is used in the first tab_footnote() call that targets the cell in the size column that is next to a name value that is stored in largest (‘Asia’). The second tab_footnote() is similar except we are supplying a conditional statement that gets the lowest population.\n\n# Determine the row that contains the\n# largest landmass ('Asia')\nlargest &lt;- \n  islands_tbl |&gt; \n  arrange(desc(size)) |&gt;\n  slice(1) |&gt;\n  pull(name)\n\n# Create two additional footnotes, using the\n# `columns` and `where` arguments of `data_cells()`\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_footnote(\n    footnote = md(\"The **largest** by area.\"),\n    locations = cells_body(\n      columns = size,\n      rows = name == largest\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"The lowest by population.\",\n    locations = cells_body(\n      columns = size,\n      rows = size == min(size)\n    )\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      name\n      size\n    \n  \n  \n    Asia\n1 16988\n    Africa\n11506\n    North America2\n9390\n    South America2\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n3 280\n  \n  \n    \n      Source: The World Almanac and Book of Facts, 1975, page 406.\n    \n    \n      Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n    \n  \n  \n    \n      1 The largest by area.\n    \n    \n      2 The Americas.\n    \n    \n      3 The lowest by population.\n    \n  \n\n\n\n\nWe were able to supply the reference locations in the table by using the cells_body() helper function and supplying the necessary targeting through the columns and rows arguments. Other cells_*() functions have similar interfaces and they allow us to target cells in different parts of the table.\n\n\nThe Stub\nThe Stub is the area to the left in a table that contains row labels, and may contain row group labels, and summary labels. Those subparts can be grouped in a sequence of row groups. The Stub Head provides a location for a label that describes the Stub. The Stub is optional since there are cases where a Stub wouldn’t be useful (e.g., the display tables presented above were just fine without a Stub).\nAn easy way to generate a Stub part is by specifying a stub column in the gt() function with the rowname_col argument. This will signal to gt that the named column should be used as the stub, making row labels. Let’s add a stub with our islands_tbl dataset by modifying the call to gt():\n\n# Create a gt table showing ten of the\n# largest islands in the world; this\n# time with a stub\ngt_tbl &lt;- \n  islands_tbl |&gt;\n  gt(rowname_col = \"name\")\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n    \n      \n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n  \n\n\n\n\nNotice that the landmass names are off the the left in an unstriped area? That’s the stub. We can apply what’s known as a stubhead label. This label can be added with the tab_stubhead() function:\n\n# Generate a simple table with a stub\n# and add a stubhead label\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_stubhead(label = \"landmass\")\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n    \n      landmass\n      size\n    \n  \n  \n    Asia\n16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n  \n\n\n\n\nA very important thing to note here is that the table now has one column. Before, when there was no stub, two columns were present (with column labels name and size) but now column number 1 (the only column) is size.\nTo apply our table parts as before (up to and including the footnotes) we use the following statements:\n\n# Display the `islands_tbl` data with a stub,\n# a heading, source notes, and footnotes\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  tab_header(\n    title = \"Large Landmasses of the World\",\n    subtitle = \"The top ten largest are presented\"\n  ) |&gt;\n  tab_source_note(\n    source_note = \"Source: The World Almanac and Book of Facts, 1975, page 406.\"\n  ) |&gt;\n  tab_source_note(\n    source_note = md(\"Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.\")\n  ) |&gt;\n  tab_footnote(\n    footnote = md(\"The **largest** by area.\"),\n    locations = cells_body(\n      columns = size, rows = largest\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"The lowest by population.\",\n    locations = cells_body(\n      columns = size, rows = contains(\"arc\")\n    )\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      landmass\n      size\n    \n  \n  \n    Asia\n1 16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n2 5500\n    Europe\n3745\n    Australia\n2968\n    Greenland\n840\n    New Guinea\n306\n    Borneo\n280\n  \n  \n    \n      Source: The World Almanac and Book of Facts, 1975, page 406.\n    \n    \n      Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n    \n  \n  \n    \n      1 The largest by area.\n    \n    \n      2 The lowest by population.\n    \n  \n\n\n\n\nLet’s incorporate row groups into the display table. This divides rows into groups, creating row groups, and results in a display of a row group labels right above the each group. This can be easily done with a table containing row labels. We can make a new row group with each call of the tab_row_group() function. The inputs are row group names in the label argument, and row references in the rows argument. We can use any of the strategies to reference rows as we did we footnotes (e.g., vectors of names/indices, select helpers, etc.).\nHere we will create three row groups (with row group labels continent, country, and subregion) to have a grouping of rows.\n\n# Create three row groups with the\n# `tab_row_group()` function\ngt_tbl &lt;- \n  gt_tbl |&gt; \n  tab_row_group(\n    label = \"continent\",\n    rows = 1:6\n  ) |&gt;\n  tab_row_group(\n    label = \"country\",\n    rows = c(\"Australia\", \"Greenland\")\n  ) |&gt;\n  tab_row_group(\n    label = \"subregion\",\n    rows = c(\"New Guinea\", \"Borneo\")\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      Large Landmasses of the World\n    \n    \n      The top ten largest are presented\n    \n    \n      landmass\n      size\n    \n  \n  \n    \n      subregion\n    \n    New Guinea\n306\n    Borneo\n280\n    \n      country\n    \n    Australia\n2968\n    Greenland\n840\n    \n      continent\n    \n    Asia\n1 16988\n    Africa\n11506\n    North America\n9390\n    South America\n6795\n    Antarctica\n2 5500\n    Europe\n3745\n  \n  \n    \n      Source: The World Almanac and Book of Facts, 1975, page 406.\n    \n    \n      Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n    \n  \n  \n    \n      1 The largest by area.\n    \n    \n      2 The lowest by population.\n    \n  \n\n\n\n\nThree row groups have been made since there are three unique categories under groupname. Across the top of each row group is the row group label contained in a separate row (these cut across the field and they contain nothing but the row group label). A rearrangement of rows is carried out to ensure each of the rows is collected within the appropriate row groups.\nHaving groups of rows in row groups is a great way to present information. Including data summaries particular to each group is a natural extension of this idea. This process of adding summary rows with summary labels is covered in a separate article (Creating Summary Lines).\nAnother way to make row groups is to have a column of group names present in the input data table. For our above example with islands_tbl, having a groupname column with the categories continent, country, and subregion in the appropriate rows would produce row groups when using the gt() function’s groupname_col argument (e.g., gt(islands_tbl, rowname_col = \"name\", groupname_col = \"groupname\") |&gt; ...). Then, there would be no need to use the tab_row_group() statements. This strategy of supplying group names in a column can sometimes be advantageous since we can rely on functions such as those available in dplyr to generate the categories (e.g., using case_when() or if_else()).\n\n\nThe Column Labels\nThe table’s Column Labels part contains, at a minimum, columns and their column labels. The last example had a single column: size. Just as in the Stub, we can create groupings called spanner columns that encompass one or more columns.\nTo better demonstrate how Column Labels work and are displayed, let’s use an input data table with more columns. In this case, that input table will be airquality. It has the following columns:\n\nOzone: mean ground-level ozone in parts per billion by volume (ppbV), measured between 13:00 and 15:00\nSolar.R: solar radiation in Langley units (cal/m2), measured between 08:00 and noon\nWind: mean wind speed in miles per hour (mph)\nTemp: maximum daily air temperature in degrees Fahrenheit (°F)\nMonth, Day: the numeric month and day of month for the record\n\nWe know that all measurements took place in 1973, so a year column will be added to the dataset before it is passed to gt().\nLet’s organize the time information under a Time spanner column label, and put the other columns under a Measurement spanner column label. We can do this with the tab_spanner() function.\n\n# Modify the `airquality` dataset by adding the year\n# of the measurements (1973) and limiting to 10 rows\nairquality_m &lt;- \n  airquality |&gt;\n  mutate(Year = 1973L) |&gt;\n  slice(1:10)\n  \n# Create a display table using the `airquality`\n# dataset; arrange columns into groups\ngt_tbl &lt;- \n  gt(airquality_m) |&gt;\n  tab_header(\n    title = \"New York Air Quality Measurements\",\n    subtitle = \"Daily measurements in New York City (May 1-10, 1973)\"\n  ) |&gt;\n  tab_spanner(\n    label = \"Time\",\n    columns = c(Year, Month, Day)\n  ) |&gt;\n  tab_spanner(\n    label = \"Measurement\",\n    columns = c(Ozone, Solar.R, Wind, Temp)\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      New York Air Quality Measurements\n    \n    \n      Daily measurements in New York City (May 1-10, 1973)\n    \n    \n      \n        Measurement\n      \n      \n        Time\n      \n    \n    \n      Ozone\n      Solar.R\n      Wind\n      Temp\n      Year\n      Month\n      Day\n    \n  \n  \n    41\n190\n7.4\n67\n1973\n5\n1\n    36\n118\n8.0\n72\n1973\n5\n2\n    12\n149\n12.6\n74\n1973\n5\n3\n    18\n313\n11.5\n62\n1973\n5\n4\n    NA\nNA\n14.3\n56\n1973\n5\n5\n    28\nNA\n14.9\n66\n1973\n5\n6\n    23\n299\n8.6\n65\n1973\n5\n7\n    19\n99\n13.8\n59\n1973\n5\n8\n    8\n19\n20.1\n61\n1973\n5\n9\n    NA\n194\n8.6\n69\n1973\n5\n10\n  \n  \n  \n\n\n\n\nWe can do two more things to make this presentable:\n\nmove the Time columns to the beginning of the series (using cols_move_to_start())\ncustomize the column labels so that they are more descriptive (using cols_label())\n\nLet’s do both of these things in the next example.\n\n# Move the time-based columns to the start of\n# the column series; modify the column labels of\n# the measurement-based columns\ngt_tbl &lt;- \n  gt_tbl |&gt;\n  cols_move_to_start(\n    columns = c(Year, Month, Day)\n  ) |&gt;\n  cols_label(\n    Ozone = html(\"Ozone,&lt;br&gt;ppbV\"),\n    Solar.R = html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n    Wind = html(\"Wind,&lt;br&gt;mph\"),\n    Temp = html(\"Temp,&lt;br&gt;&deg;F\")\n  )\n\n# Show the gt table\ngt_tbl\n\n\n\n\n\n  \n    \n      New York Air Quality Measurements\n    \n    \n      Daily measurements in New York City (May 1-10, 1973)\n    \n    \n      \n        Time\n      \n      \n        Measurement\n      \n    \n    \n      Year\n      Month\n      Day\n      Ozone,ppbV\n      Solar R.,cal/m2\n      Wind,mph\n      Temp,°F\n    \n  \n  \n    1973\n5\n1\n41\n190\n7.4\n67\n    1973\n5\n2\n36\n118\n8.0\n72\n    1973\n5\n3\n12\n149\n12.6\n74\n    1973\n5\n4\n18\n313\n11.5\n62\n    1973\n5\n5\nNA\nNA\n14.3\n56\n    1973\n5\n6\n28\nNA\n14.9\n66\n    1973\n5\n7\n23\n299\n8.6\n65\n    1973\n5\n8\n19\n99\n13.8\n59\n    1973\n5\n9\n8\n19\n20.1\n61\n    1973\n5\n10\nNA\n194\n8.6\n69\n  \n  \n  \n\n\n\n\nNote that even though columns were moved using cols_move_to_start(), the spanner column labels still spanned above the correct column labels. There are a number of functions that gt provides to move columns, including cols_move(), cols_move_to_end(); there’s even a function to hide columns: cols_hide().\nMultiple columns can be renamed in a single use of cols_label(). Further to this, the helper functions md() and html() can be used to create column labels with additional styling. In the above example, we provided column labels as HTML so that we can insert linebreaks with &lt;br&gt;, insert a superscripted 2 (with &lt;sup&gt;2&lt;/sup&gt;), and insert a degree symbol as an HTML entity (&deg;)."
  },
  {
    "objectID": "tableexport.html",
    "href": "tableexport.html",
    "title": "Table Exporting",
    "section": "",
    "text": "All gt tables begin with a call to gt(), where we would supply the input data table (data frame or tibble) and some basic options for creating a stub (rowname_col) and row groups (groupname_col). We can also introduce a grouped tibble (via dplyr’s group_by()) for more precise divisions of rows into row groups.\nThe gt_preview() function is great for getting a nicely-formatted preview of a data table (defaulting to the first 5 rows and the last row).\nFinally, sometimes we want to export the table to some format. It could be HTML, it could be RTF… whichever you go with, you can use the gtsave() function.\n\n\n\n\ngt()\ngt_preview()\ngtsave()\n\n\n\n\n\ngt(\n  data,\n  rowname_col = \"rowname\",\n  groupname_col = dplyr::group_vars(data),\n  process_md = FALSE,\n  caption = NULL,\n  rownames_to_stub = FALSE,\n  row_group_as_column = FALSE,\n  auto_align = TRUE,\n  id = NULL,\n  locale = NULL,\n  row_group.sep = getOption(\"gt.row_group.sep\", \" - \")\n)\nThe gt() function creates a gt table object when provided with table data. Using this function is the first step in a typical gt workflow. Once we have the gt table object, we can perform styling transformations before rendering to a display table of various formats.\n\n\nThe gt package contains a few datasets:\n\ncountrypops - Yearly populations of countries from 1960 to 2017\nsza - Twice hourly solar zenith angles by month & latitude\ngtcars - Deluxe automobiles from the 2014-2017 period\nsp500 - Daily S&P 500 Index data from 1950 to 2015\npizzaplace - A year of pizza sales from a pizza place\nexibble - A toy example tibble for testing with gt: exibble\ntowny - Populations of all municipalities in Ontario from 1996 to 2021\nmetro - The stations of the Paris Metro\nrx_adsl - An ADSL-flavored clinical trial toy dataset\nrx_addv - An ADDV-flavored clinical trial toy dataset\n\nWe will use exibble frequently during this workshop simply because the entire table easily fits on a screen and contains various types of data (i.e., it’s ideal for examples).\nLet’s print out exibble and see what it looks like:\n\nexibble\n\n# A tibble: 8 × 9\n          num char       fctr  date       time  datetime    currency row   group\n        &lt;dbl&gt; &lt;chr&gt;      &lt;fct&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1       0.111 apricot    one   2015-01-15 13:35 2018-01-01…    50.0  row_1 grp_a\n2       2.22  banana     two   2015-02-15 14:40 2018-02-02…    18.0  row_2 grp_a\n3      33.3   coconut    three 2015-03-15 15:45 2018-03-03…     1.39 row_3 grp_a\n4     444.    durian     four  2015-04-15 16:50 2018-04-04… 65100    row_4 grp_a\n5    5550     &lt;NA&gt;       five  2015-05-15 17:55 2018-05-05…  1326.   row_5 grp_b\n6      NA     fig        six   2015-06-15 &lt;NA&gt;  2018-06-06…    13.3  row_6 grp_b\n7  777000     grapefruit seven &lt;NA&gt;       19:10 2018-07-07…    NA    row_7 grp_b\n8 8880000     honeydew   eight 2015-08-15 20:20 &lt;NA&gt;            0.44 row_8 grp_b\n\n\nNow lets introduce exibble to the gt() function.\n\nexibble |&gt; gt()\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n  \n\n\n\n\nThe above is the basic layout, containing the column labels and the body cells. Numbers are minimally formatted (see the num column) but we can apply our own specific formatting (in the next module).\nWe can modify the layout a bit in the first step and create a stub. A stub is a special column that contains row labels/names. To do this, we supply the name of the column we’d like to use as the stub to the rowname_col argument. Conveniently, we have the \"row\" column in exibble that’s good for this purpose:\n\nexibble |&gt; gt(rowname_col = \"row\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      group\n    \n  \n  \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\ngrp_a\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\ngrp_a\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\ngrp_a\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\ngrp_a\n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\ngrp_b\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\ngrp_b\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\ngrp_b\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\ngrp_b\n  \n  \n  \n\n\n\n\nGreat! A bit on the stub. It doesn’t have a column label above it because it’s technically not a column. We can still put a label above it though, and this is done with the tab_stubhead() function (demo for this in the next module).\nWe can do some more structuring. Sets of rows can be grouped, showing a row group label above each group. We can do this by using a column containing categorical values (usually grouping labels). Conveniently again, exibble has the \"group\" column. Let’s use that in the rowname_col argument of gt() and see what it looks like:\n\nexibble |&gt;\n  gt(rowname_col = \"row\", groupname_col = \"group\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n    \n      grp_b\n    \n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n  \n  \n  \n\n\n\n\nEven if rows are in an undesirable order, gt will put the rows in the correct group (but still respect the order of rows).\n\nexibble |&gt;\n  dplyr::sample_n(size = 8) |&gt;\n  gt(rowname_col = \"row\", groupname_col = \"group\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_b\n    \n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    \n      grp_a\n    \n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n  \n  \n  \n\n\n\n\nSay you have a data frame with row names (like mtcars). You can put those row.names in the stub with rownames_to_stub = TRUE:\n\nmtcars |&gt;\n  dplyr::slice_head(n = 10) |&gt;\n  gt(rownames_to_stub = TRUE)\n\n\n\n\n\n  \n    \n    \n      \n      mpg\n      cyl\n      disp\n      hp\n      drat\n      wt\n      qsec\n      vs\n      am\n      gear\n      carb\n    \n  \n  \n    Mazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n    Mazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n    Datsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n    Hornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n    Hornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n    Valiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n    Duster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n    Merc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n    Merc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n    Merc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n  \n  \n  \n\n\n\n\nIf you use dplyr then you’re probably familiar with the group_by() function. This will generate a grouped tibble, and you can pass that into gt(). The package will know what to do with a grouped tibble:\n\nexibble |&gt; \n  dplyr::group_by(group) |&gt;\n  gt(rowname_col = \"row\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n    \n      grp_b\n    \n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n  \n  \n  \n\n\n\n\nThis also works if you have multiple columns grouped. Use row_group.sep to specify the separator between labels.\n\npizzaplace |&gt; \n  dplyr::filter(type %in% c(\"supreme\", \"veggie\")) |&gt;\n  dplyr::group_by(type, size) |&gt;\n  dplyr::slice_head(n = 3) |&gt;\n  gt(row_group.sep = \" // \")\n\n\n\n\n\n  \n    \n    \n      id\n      date\n      time\n      name\n      price\n    \n  \n  \n    \n      supreme // L\n    \n    2015-000002\n2015-01-01\n11:57:40\nital_supr\n20.75\n    2015-000003\n2015-01-01\n12:12:28\nprsc_argla\n20.75\n    2015-000009\n2015-01-01\n12:52:01\nital_supr\n20.75\n    \n      supreme // M\n    \n    2015-000003\n2015-01-01\n12:12:28\nital_supr\n16.50\n    2015-000004\n2015-01-01\n12:16:31\nital_supr\n16.50\n    2015-000005\n2015-01-01\n12:21:30\nital_supr\n16.50\n    \n      supreme // S\n    \n    2015-000007\n2015-01-01\n12:50:37\nspinach_supr\n12.50\n    2015-000008\n2015-01-01\n12:51:37\nspinach_supr\n12.50\n    2015-000009\n2015-01-01\n12:52:01\nital_supr\n12.50\n    \n      veggie // L\n    \n    2015-000002\n2015-01-01\n11:57:40\nfive_cheese\n18.50\n    2015-000009\n2015-01-01\n12:52:01\nspin_pesto\n20.75\n    2015-000010\n2015-01-01\n13:00:15\nmexicana\n20.25\n    \n      veggie // M\n    \n    2015-000002\n2015-01-01\n11:57:40\nmexicana\n16.00\n    2015-000017\n2015-01-01\n13:53:00\nmediterraneo\n16.00\n    2015-000017\n2015-01-01\n13:53:00\nfour_cheese\n14.75\n    \n      veggie // S\n    \n    2015-000009\n2015-01-01\n12:52:01\nmexicana\n12.00\n    2015-000009\n2015-01-01\n12:52:01\nveggie_veg\n12.00\n    2015-000009\n2015-01-01\n12:52:01\ngreen_garden\n12.00\n  \n  \n  \n\n\n\n\n\n\n\n\n\ngt_preview(\n  data,\n  top_n = 5,\n  bottom_n = 1,\n  incl_rownums = TRUE\n)\nSometimes you may want to see just a small portion of your input data. We can use gt_preview() in place of gt() to get the first x rows of data and the last y rows of data (which can be set by the top_n and bottom_n arguments).\n\n\nUse gtcars to create a gt table preview (with only a few of its columns). You’ll see the first five rows and the last row.\n\ngtcars |&gt;\n  dplyr::select(mfr, model, year) |&gt;\n  gt_preview()\n\n\n\n\n\n  \n    \n    \n      \n      mfr\n      model\n      year\n    \n  \n  \n    1\nFord\nGT\n2017\n    2\nFerrari\n458 Speciale\n2015\n    3\nFerrari\n458 Spider\n2015\n    4\nFerrari\n458 Italia\n2014\n    5\nFerrari\n488 GTB\n2016\n    6..46\n\n\n\n    47\nRolls-Royce\nWraith\n2016\n  \n  \n  \n\n\n\n\nDon’t want to see the row numbers? They can be excluded by using incl_rownums = FALSE.\n\nsp500 |&gt; \n  gt_preview(\n    bottom_n = 5,\n    incl_rownums = FALSE\n  )\n\n\n\n\n\n  \n    \n    \n      date\n      open\n      high\n      low\n      close\n      volume\n      adj_close\n    \n  \n  \n    2015-12-31\n2060.59\n2062.54\n2043.62\n2043.94\n2655330000\n2043.94\n    2015-12-30\n2077.34\n2077.34\n2061.97\n2063.36\n2367430000\n2063.36\n    2015-12-29\n2060.54\n2081.56\n2060.54\n2078.36\n2542000000\n2078.36\n    2015-12-28\n2057.77\n2057.77\n2044.20\n2056.50\n2492510000\n2056.50\n    2015-12-24\n2063.52\n2067.36\n2058.73\n2060.99\n1411860000\n2060.99\n    \n\n\n\n\n\n\n    1950-01-09\n17.08\n17.08\n17.08\n17.08\n2520000\n17.08\n    1950-01-06\n16.98\n16.98\n16.98\n16.98\n2010000\n16.98\n    1950-01-05\n16.93\n16.93\n16.93\n16.93\n2550000\n16.93\n    1950-01-04\n16.85\n16.85\n16.85\n16.85\n1890000\n16.85\n    1950-01-03\n16.66\n16.66\n16.66\n16.66\n1260000\n16.66\n  \n  \n  \n\n\n\n\n\n\n\n\n\ngtsave(\n  data,\n  filename,\n  path = NULL,\n  ...\n)\nThe gtsave() function makes it easy to save a gt table to a file. The function assumes the output file type by the extension provided in the output filename. This will produce either an HTML, PDF, PNG, LaTeX, RTF, or docx file.\n\n\nUse exibble to create a gt table.\n\ngt_tbl &lt;-\n  exibble |&gt;\n  gt(\n    rowname_col = \"row\",\n    groupname_col = \"group\"\n  )\n\nWrite an HTML file.\n\ngt_tbl |&gt; gtsave(\"tab_1.html\", inline_css = FALSE)\n\nGet a PNG file (essentially a screenshot of the HTML table) by using the .png extension.\n\n#gt_tbl |&gt; gtsave(\"tab_r.png\")\n\nGet an RTF file by using the .rtf extension in the filename.\n\n#gt_tbl |&gt; gtsave(\"tab_r.rtf\")\n\n\n\n\n\n\n\nTo make a gt table, get your input table in the right arrangement and use gt().\nThe gt() function has a few options for adding group rows and a stub.\nIf you need a quick preview of a table (regardless of the table’s size) try using gt_preview()\nYou can save a gt table in a file with gtsave(); you have to name the file in a supported format (e.g., \"gt_table.rtf\" for an RTF file containing the table)."
  },
  {
    "objectID": "tableexport.html#intro",
    "href": "tableexport.html#intro",
    "title": "Table Exporting",
    "section": "",
    "text": "All gt tables begin with a call to gt(), where we would supply the input data table (data frame or tibble) and some basic options for creating a stub (rowname_col) and row groups (groupname_col). We can also introduce a grouped tibble (via dplyr’s group_by()) for more precise divisions of rows into row groups.\nThe gt_preview() function is great for getting a nicely-formatted preview of a data table (defaulting to the first 5 rows and the last row).\nFinally, sometimes we want to export the table to some format. It could be HTML, it could be RTF… whichever you go with, you can use the gtsave() function.\n\n\n\n\ngt()\ngt_preview()\ngtsave()\n\n\n\n\n\ngt(\n  data,\n  rowname_col = \"rowname\",\n  groupname_col = dplyr::group_vars(data),\n  process_md = FALSE,\n  caption = NULL,\n  rownames_to_stub = FALSE,\n  row_group_as_column = FALSE,\n  auto_align = TRUE,\n  id = NULL,\n  locale = NULL,\n  row_group.sep = getOption(\"gt.row_group.sep\", \" - \")\n)\nThe gt() function creates a gt table object when provided with table data. Using this function is the first step in a typical gt workflow. Once we have the gt table object, we can perform styling transformations before rendering to a display table of various formats.\n\n\nThe gt package contains a few datasets:\n\ncountrypops - Yearly populations of countries from 1960 to 2017\nsza - Twice hourly solar zenith angles by month & latitude\ngtcars - Deluxe automobiles from the 2014-2017 period\nsp500 - Daily S&P 500 Index data from 1950 to 2015\npizzaplace - A year of pizza sales from a pizza place\nexibble - A toy example tibble for testing with gt: exibble\ntowny - Populations of all municipalities in Ontario from 1996 to 2021\nmetro - The stations of the Paris Metro\nrx_adsl - An ADSL-flavored clinical trial toy dataset\nrx_addv - An ADDV-flavored clinical trial toy dataset\n\nWe will use exibble frequently during this workshop simply because the entire table easily fits on a screen and contains various types of data (i.e., it’s ideal for examples).\nLet’s print out exibble and see what it looks like:\n\nexibble\n\n# A tibble: 8 × 9\n          num char       fctr  date       time  datetime    currency row   group\n        &lt;dbl&gt; &lt;chr&gt;      &lt;fct&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1       0.111 apricot    one   2015-01-15 13:35 2018-01-01…    50.0  row_1 grp_a\n2       2.22  banana     two   2015-02-15 14:40 2018-02-02…    18.0  row_2 grp_a\n3      33.3   coconut    three 2015-03-15 15:45 2018-03-03…     1.39 row_3 grp_a\n4     444.    durian     four  2015-04-15 16:50 2018-04-04… 65100    row_4 grp_a\n5    5550     &lt;NA&gt;       five  2015-05-15 17:55 2018-05-05…  1326.   row_5 grp_b\n6      NA     fig        six   2015-06-15 &lt;NA&gt;  2018-06-06…    13.3  row_6 grp_b\n7  777000     grapefruit seven &lt;NA&gt;       19:10 2018-07-07…    NA    row_7 grp_b\n8 8880000     honeydew   eight 2015-08-15 20:20 &lt;NA&gt;            0.44 row_8 grp_b\n\n\nNow lets introduce exibble to the gt() function.\n\nexibble |&gt; gt()\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n  \n\n\n\n\nThe above is the basic layout, containing the column labels and the body cells. Numbers are minimally formatted (see the num column) but we can apply our own specific formatting (in the next module).\nWe can modify the layout a bit in the first step and create a stub. A stub is a special column that contains row labels/names. To do this, we supply the name of the column we’d like to use as the stub to the rowname_col argument. Conveniently, we have the \"row\" column in exibble that’s good for this purpose:\n\nexibble |&gt; gt(rowname_col = \"row\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      group\n    \n  \n  \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\ngrp_a\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\ngrp_a\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\ngrp_a\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\ngrp_a\n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\ngrp_b\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\ngrp_b\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\ngrp_b\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\ngrp_b\n  \n  \n  \n\n\n\n\nGreat! A bit on the stub. It doesn’t have a column label above it because it’s technically not a column. We can still put a label above it though, and this is done with the tab_stubhead() function (demo for this in the next module).\nWe can do some more structuring. Sets of rows can be grouped, showing a row group label above each group. We can do this by using a column containing categorical values (usually grouping labels). Conveniently again, exibble has the \"group\" column. Let’s use that in the rowname_col argument of gt() and see what it looks like:\n\nexibble |&gt;\n  gt(rowname_col = \"row\", groupname_col = \"group\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n    \n      grp_b\n    \n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n  \n  \n  \n\n\n\n\nEven if rows are in an undesirable order, gt will put the rows in the correct group (but still respect the order of rows).\n\nexibble |&gt;\n  dplyr::sample_n(size = 8) |&gt;\n  gt(rowname_col = \"row\", groupname_col = \"group\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_b\n    \n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    \n      grp_a\n    \n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n  \n  \n  \n\n\n\n\nSay you have a data frame with row names (like mtcars). You can put those row.names in the stub with rownames_to_stub = TRUE:\n\nmtcars |&gt;\n  dplyr::slice_head(n = 10) |&gt;\n  gt(rownames_to_stub = TRUE)\n\n\n\n\n\n  \n    \n    \n      \n      mpg\n      cyl\n      disp\n      hp\n      drat\n      wt\n      qsec\n      vs\n      am\n      gear\n      carb\n    \n  \n  \n    Mazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n    Mazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n    Datsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n    Hornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n    Hornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n    Valiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n    Duster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n    Merc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n    Merc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n    Merc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n  \n  \n  \n\n\n\n\nIf you use dplyr then you’re probably familiar with the group_by() function. This will generate a grouped tibble, and you can pass that into gt(). The package will know what to do with a grouped tibble:\n\nexibble |&gt; \n  dplyr::group_by(group) |&gt;\n  gt(rowname_col = \"row\")\n\n\n\n\n\n  \n    \n    \n      \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\n    row_2\n2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\n    row_3\n3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\n    row_4\n4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\n    \n      grp_b\n    \n    row_5\n5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\n    row_6\nNA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\n    row_7\n7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\n    row_8\n8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\n  \n  \n  \n\n\n\n\nThis also works if you have multiple columns grouped. Use row_group.sep to specify the separator between labels.\n\npizzaplace |&gt; \n  dplyr::filter(type %in% c(\"supreme\", \"veggie\")) |&gt;\n  dplyr::group_by(type, size) |&gt;\n  dplyr::slice_head(n = 3) |&gt;\n  gt(row_group.sep = \" // \")\n\n\n\n\n\n  \n    \n    \n      id\n      date\n      time\n      name\n      price\n    \n  \n  \n    \n      supreme // L\n    \n    2015-000002\n2015-01-01\n11:57:40\nital_supr\n20.75\n    2015-000003\n2015-01-01\n12:12:28\nprsc_argla\n20.75\n    2015-000009\n2015-01-01\n12:52:01\nital_supr\n20.75\n    \n      supreme // M\n    \n    2015-000003\n2015-01-01\n12:12:28\nital_supr\n16.50\n    2015-000004\n2015-01-01\n12:16:31\nital_supr\n16.50\n    2015-000005\n2015-01-01\n12:21:30\nital_supr\n16.50\n    \n      supreme // S\n    \n    2015-000007\n2015-01-01\n12:50:37\nspinach_supr\n12.50\n    2015-000008\n2015-01-01\n12:51:37\nspinach_supr\n12.50\n    2015-000009\n2015-01-01\n12:52:01\nital_supr\n12.50\n    \n      veggie // L\n    \n    2015-000002\n2015-01-01\n11:57:40\nfive_cheese\n18.50\n    2015-000009\n2015-01-01\n12:52:01\nspin_pesto\n20.75\n    2015-000010\n2015-01-01\n13:00:15\nmexicana\n20.25\n    \n      veggie // M\n    \n    2015-000002\n2015-01-01\n11:57:40\nmexicana\n16.00\n    2015-000017\n2015-01-01\n13:53:00\nmediterraneo\n16.00\n    2015-000017\n2015-01-01\n13:53:00\nfour_cheese\n14.75\n    \n      veggie // S\n    \n    2015-000009\n2015-01-01\n12:52:01\nmexicana\n12.00\n    2015-000009\n2015-01-01\n12:52:01\nveggie_veg\n12.00\n    2015-000009\n2015-01-01\n12:52:01\ngreen_garden\n12.00\n  \n  \n  \n\n\n\n\n\n\n\n\n\ngt_preview(\n  data,\n  top_n = 5,\n  bottom_n = 1,\n  incl_rownums = TRUE\n)\nSometimes you may want to see just a small portion of your input data. We can use gt_preview() in place of gt() to get the first x rows of data and the last y rows of data (which can be set by the top_n and bottom_n arguments).\n\n\nUse gtcars to create a gt table preview (with only a few of its columns). You’ll see the first five rows and the last row.\n\ngtcars |&gt;\n  dplyr::select(mfr, model, year) |&gt;\n  gt_preview()\n\n\n\n\n\n  \n    \n    \n      \n      mfr\n      model\n      year\n    \n  \n  \n    1\nFord\nGT\n2017\n    2\nFerrari\n458 Speciale\n2015\n    3\nFerrari\n458 Spider\n2015\n    4\nFerrari\n458 Italia\n2014\n    5\nFerrari\n488 GTB\n2016\n    6..46\n\n\n\n    47\nRolls-Royce\nWraith\n2016\n  \n  \n  \n\n\n\n\nDon’t want to see the row numbers? They can be excluded by using incl_rownums = FALSE.\n\nsp500 |&gt; \n  gt_preview(\n    bottom_n = 5,\n    incl_rownums = FALSE\n  )\n\n\n\n\n\n  \n    \n    \n      date\n      open\n      high\n      low\n      close\n      volume\n      adj_close\n    \n  \n  \n    2015-12-31\n2060.59\n2062.54\n2043.62\n2043.94\n2655330000\n2043.94\n    2015-12-30\n2077.34\n2077.34\n2061.97\n2063.36\n2367430000\n2063.36\n    2015-12-29\n2060.54\n2081.56\n2060.54\n2078.36\n2542000000\n2078.36\n    2015-12-28\n2057.77\n2057.77\n2044.20\n2056.50\n2492510000\n2056.50\n    2015-12-24\n2063.52\n2067.36\n2058.73\n2060.99\n1411860000\n2060.99\n    \n\n\n\n\n\n\n    1950-01-09\n17.08\n17.08\n17.08\n17.08\n2520000\n17.08\n    1950-01-06\n16.98\n16.98\n16.98\n16.98\n2010000\n16.98\n    1950-01-05\n16.93\n16.93\n16.93\n16.93\n2550000\n16.93\n    1950-01-04\n16.85\n16.85\n16.85\n16.85\n1890000\n16.85\n    1950-01-03\n16.66\n16.66\n16.66\n16.66\n1260000\n16.66\n  \n  \n  \n\n\n\n\n\n\n\n\n\ngtsave(\n  data,\n  filename,\n  path = NULL,\n  ...\n)\nThe gtsave() function makes it easy to save a gt table to a file. The function assumes the output file type by the extension provided in the output filename. This will produce either an HTML, PDF, PNG, LaTeX, RTF, or docx file.\n\n\nUse exibble to create a gt table.\n\ngt_tbl &lt;-\n  exibble |&gt;\n  gt(\n    rowname_col = \"row\",\n    groupname_col = \"group\"\n  )\n\nWrite an HTML file.\n\ngt_tbl |&gt; gtsave(\"tab_1.html\", inline_css = FALSE)\n\nGet a PNG file (essentially a screenshot of the HTML table) by using the .png extension.\n\n#gt_tbl |&gt; gtsave(\"tab_r.png\")\n\nGet an RTF file by using the .rtf extension in the filename.\n\n#gt_tbl |&gt; gtsave(\"tab_r.rtf\")\n\n\n\n\n\n\n\nTo make a gt table, get your input table in the right arrangement and use gt().\nThe gt() function has a few options for adding group rows and a stub.\nIf you need a quick preview of a table (regardless of the table’s size) try using gt_preview()\nYou can save a gt table in a file with gtsave(); you have to name the file in a supported format (e.g., \"gt_table.rtf\" for an RTF file containing the table)."
  },
  {
    "objectID": "modify.html",
    "href": "modify.html",
    "title": "Modify",
    "section": "",
    "text": "A gt table can contain a few useful parts for conveying additional information. These include a header (with a titles and subtitle), a footer (with footnotes and source notes), and additional areas for labels (row group labels, column spanner labels, the stubhead label). We can modify the look of table parts more generally with tab_options() and perform styling on targeted table locations with tab_style().\n\n\n\n\ntab_header()\ntab_stubhead()\ntab_spanner()\ntab_row_group()\ntab_source_note()\ntab_footnote()\ntab_style()\ntab_options()\n\nSome of the helper functions for selecting columns and rows:\n\ncontains()\nmatches()\nstarts_with()\nends_with()\neverything()\n\nHelpers for transforming text:\n\nmd()\nhtml()\n\nHelpers for targeting locations (for tab_footnote() and tab_style()):\n\ncells_title()\ncells_stubhead()\ncells_column_spanners()\ncells_column_labels()\ncells_row_groups()\ncells_stub()\ncells_body()\ncells_summary()\ncells_grand_summary()\n\nHelpers for defining styles (only for tab_style()):\n\ncell_text()\ncell_fill()\ncell_borders()\n\n\n\n\n\ntab_header(\n  data,\n  title,\n  subtitle = NULL,\n  preheader = NULL\n)\nWe can add a table header to the gt table with a title and optionally a subtitle. A table header is an optional table part that is positioned above the column labels. We have the flexibility to use Markdown or HTML formatting for the header’s title and subtitle (with md() or html()).\n\n\nUse gtcars to create a gt table; add a header part to contain a title and subtitle.\n\ngtcars |&gt;\n  dplyr::select(mfr, model, msrp) |&gt;\n  dplyr::slice(1:5) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = md(\"Data listing from **gtcars**\"),\n    subtitle = md(\"`gtcars` is an R dataset\")\n  )\n\n\n\n\n\n  \n    \n      Data listing from gtcars\n    \n    \n      gtcars is an R dataset\n    \n    \n      mfr\n      model\n      msrp\n    \n  \n  \n    Ford\nGT\n447000\n    Ferrari\n458 Speciale\n291744\n    Ferrari\n458 Spider\n263553\n    Ferrari\n458 Italia\n233509\n    Ferrari\n488 GTB\n245400\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_stubhead(\n  data,\n  label\n)\nAdd a label to the stubhead of a gt table. The stubhead is the lone element that is positioned left of the column labels, and above the stub. We have the flexibility to use Markdown formatting for the stubhead label with md(). Furthermore, if the table is intended for HTML output, we can use HTML for the stubhead label (with html()).\n\n\nUse gtcars to create a gt table. Add a stubhead label to describe what is in the stub.\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:5) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_stubhead(label = \"car\")\n\n\n\n\n\n  \n    \n    \n      car\n      year\n      hp\n      trq\n    \n  \n  \n    GT\n2017\n647\n550\n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    488 GTB\n2016\n661\n561\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_spanner(\n  data,\n  label,\n  columns = NULL,\n  spanners = NULL,\n  level = NULL,\n  id = label,\n  gather = TRUE,\n  replace = FALSE\n)\nSet a spanner column label by mapping it to columns already in the table. This label is placed above one or more column labels, spanning the width of those columns and column labels.\nWith columns we can use column names in double quotes (\"&lt;column&gt;\"), in c() (c(&lt;column&gt;)), or, we can use the following tidyselect expressions:\n\ncontains(): contains a literal string\nmatches(): matches a regular expression\nstarts_with(): starts with a prefix\nends_with(): ends with a suffix\neverything(): selects all columns\n\n\n\nLet’s use the gtcars table, but cut it down to size first:\n\ngtcars_small &lt;- \n  gtcars |&gt;\n  dplyr::select(\n    -mfr, -trim, bdy_style, drivetrain,\n    -drivetrain, -trsmn, -ctry_origin\n  ) |&gt;\n  dplyr::slice(1:8)\n\ngtcars_small\n\n# A tibble: 8 × 10\n  model         year bdy_style      hp hp_rpm   trq trq_rpm mpg_c mpg_h   msrp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 GT            2017 coupe         647   6250   550    5900    11    18 447000\n2 458 Speciale  2015 coupe         597   9000   398    6000    13    17 291744\n3 458 Spider    2015 convertible   562   9000   398    6000    13    17 263553\n4 458 Italia    2014 coupe         562   9000   398    6000    13    17 233509\n5 488 GTB       2016 coupe         661   8000   561    3000    15    22 245400\n6 California    2015 convertible   553   7500   557    4750    16    23 198973\n7 GTC4Lusso     2017 coupe         680   8250   514    5750    12    17 298000\n8 FF            2015 coupe         652   8000   504    6000    11    16 295000\n\n\nLet’s look at the table in gt so that we know where we are starting from.\n\ngtcars_small |&gt; gt(rowname_col = \"model\")\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n      msrp\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nUse gtcars to create a gt table; Group several columns related to car performance under a spanner column with the label performance.\n\ngtcars_small |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_spanner(\n    label = \"performance\",\n    columns = c(hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h)\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      \n        performance\n      \n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nWith a few tidyselect statements in c(), we can get the same columns.\n\ngtcars_small |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_spanner(\n    label = \"performance\",\n    columns = c(starts_with(\"hp\"), starts_with(\"trq\"), starts_with(\"mpg\"))\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      \n        performance\n      \n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nIf we relocate the \"hp\" column to the beginning (i.e., far left), the associated columns are gathered together (because gather = TRUE).\n\ngtcars_small |&gt;\n  dplyr::select(hp, everything()) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n    tab_spanner(\n    label = \"performance\",\n    columns = c(hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h)\n  )\n\n\n\n\n\n  \n    \n    \n      \n      \n        performance\n      \n      year\n      bdy_style\n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n647\n6250\n550\n5900\n11\n18\n2017\ncoupe\n447000\n    458 Speciale\n597\n9000\n398\n6000\n13\n17\n2015\ncoupe\n291744\n    458 Spider\n562\n9000\n398\n6000\n13\n17\n2015\nconvertible\n263553\n    458 Italia\n562\n9000\n398\n6000\n13\n17\n2014\ncoupe\n233509\n    488 GTB\n661\n8000\n561\n3000\n15\n22\n2016\ncoupe\n245400\n    California\n553\n7500\n557\n4750\n16\n23\n2015\nconvertible\n198973\n    GTC4Lusso\n680\n8250\n514\n5750\n12\n17\n2017\ncoupe\n298000\n    FF\n652\n8000\n504\n6000\n11\n16\n2015\ncoupe\n295000\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_row_group(\n  data,\n  label,\n  rows,\n  id = label,\n  others_label = NULL,\n  group = NULL\n)\nCreate a row group with a collection of rows. This requires specification of the rows to be included, either by supplying row labels, row indices, or through use of a select helper function like starts_with(). To modify the order of row groups, use the row_group_order() function.\n\n\nUse gtcars to create a gt table and add two row groups with the labels: numbered and NA (a group without a label associated with it)\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"numbered\",\n    rows = matches(\"^[0-9]\")\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      numbered\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    488 GTB\n2016\n661\n561\n    \n      \n    \n    GT\n2017\n647\n550\n    California\n2015\n553\n557\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n  \n  \n  \n\n\n\n\nUse gtcars to create a gt table. Add two row groups with the labels powerful and more powerful: the distinction is having hp lesser or greater than 600.\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"powerful\",\n    rows = hp &lt;= 600\n  ) |&gt;\n  tab_row_group(\n    label = \"more powerful\",\n    rows = hp &gt; 600\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      more powerful\n    \n    GT\n2017\n647\n550\n    488 GTB\n2016\n661\n561\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n    \n      powerful\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    California\n2015\n553\n557\n  \n  \n  \n\n\n\n\nIf the order is not what you want, you can change the calling order of the tab_row_group() statements, or, use row_group_order() afterward:\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"powerful\",\n    rows = hp &lt;= 600\n  ) |&gt;\n  tab_row_group(\n    label = md(\"**more powerful**\"),\n    rows = hp &gt; 600,\n    id = \"more_powerful\"\n  ) |&gt;\n  row_group_order(groups = c(\"powerful\", \"more_powerful\"))\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      powerful\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    California\n2015\n553\n557\n    \n      more powerful\n    \n    GT\n2017\n647\n550\n    488 GTB\n2016\n661\n561\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_source_note(\n  data,\n  source_note\n)\nWe can add a source note to the footer part of any gt table. A source note is useful for citing the data included in the table. Several can be added, simply use multiple calls of tab_source_note() and they will be inserted in the order provided. We can use Markdown formatting for the note, or, if the table is intended for HTML output, we can include HTML formatting.\n\n\nUse exibble to create a gt table. Add a source note to the table footer that cites the data source.\n\nexibble |&gt;\n  gt() |&gt;\n  tab_source_note(\n    source_note = \"The `exibble` dataset is available in the **gt** package.\"\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n    \n      The `exibble` dataset is available in the **gt** package.\n    \n  \n  \n\n\n\n\n\n\n\n\n\ntab_footnote(\n  data,\n  footnote,\n  locations = NULL,\n  placement = c(\"auto\", \"right\", \"left\")\n)\nThe tab_footnote() function can make it a painless process to add a footnote to a gt table. There are two components to a footnote: (1) a footnote mark that is attached to the targeted cell text, and (2) the footnote text (that starts with the corresponding footnote mark) that is placed in the table’s footer area.\nEach call of tab_footnote() will add a different note, and one or more cells can be targeted via the location helper (use in locations):\n\ncells_title() - target the table title or subtitle\ncells_stubhead() - target the table stubhead cell\ncells_column_spanners() - target the column spanners\ncells_column_labels() - target the column labels\ncells_row_groups() - target row groups\ncells_stub() - target cells in the table stub\ncells_body() - target data cells in the table body\ncells_summary() - target group summary cells\ncells_grand_summary() - target cells in a grand summary\n\nAdditionally, we can enclose several cells_*() calls within a list() if we wish to link the footnote text to different types of locations (e.g., body cells, row group labels, the table title, etc.).\n\n\nUse exibble to create a gt table and then add a footnote to the fctr column label explaining what the short form means (fctr = ‘factor’).\n\nexibble |&gt;\n  gt() |&gt;\n  tab_footnote(\n    footnote = \"This is a factor column.\",\n    locations = cells_column_labels(columns = fctr)\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr1\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n  \n    \n      1 This is a factor column.\n    \n  \n\n\n\n\n\n\n\n\n\ntab_style(\n  data,\n  style,\n  locations\n)\nWith the tab_style() function we can target specific cells and apply styles to them.\nThis is done with the help of the following functions:\n\ncell_text()\ncell_fill()\ncell_borders()\n\nFor locations we use the cells_*() functions, just like in the tab_footnote() function. In the example below, we’ll take things a step further with the cells_body() function and use a conditional statement in rows to target cells based on data.\n\n\nChange the font of all body cells in the exibble table to Times New Roman. By default, using cells_body() without any arguments means all table body cells are targeted.\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  tab_style(\n    style = cell_text(font = \"Times New Roman\"),\n    locations = cells_body()\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    1.111e-01\n49.950\n    2.222e+00\n17.950\n    3.333e+01\n1.390\n    4.444e+02\n65100.000\n    5.550e+03\n1325.810\n    NA\n13.255\n    7.770e+05\nNA\n    8.880e+06\n0.440\n  \n  \n  \n\n\n\n\nUse a font from the Google Fonts service by using the google_font() function. Recommendations on some Google fonts can be found by using info_google_fonts().\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  fmt_currency(columns = currency, currency = \"EUR\") |&gt;\n  tab_style(\n    style = cell_text(font = google_font(\"IBM Plex Sans\"), weight = 500),\n    locations = cells_body()\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    1.111e-01\n€49.95\n    2.222e+00\n€17.95\n    3.333e+01\n€1.39\n    4.444e+02\n€65,100.00\n    5.550e+03\n€1,325.81\n    NA\n€13.26\n    7.770e+05\nNA\n    8.880e+06\n€0.44\n  \n  \n  \n\n\n\n\nUse exibble to create a gt table. Add styles that are to be applied to data cells that satisfy a condition (using tab_style()).\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  fmt_number(\n    columns = c(num, currency),\n    decimals = 1\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"cyan\"),\n      cell_text(weight = \"bold\")\n      ),\n    locations = cells_body(\n      columns = num,\n      rows = num &gt;= 5000\n    )\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"#F9E3D6\"),\n      cell_text(style = \"italic\")\n      ),\n    locations = cells_body(\n      columns = currency,\n      rows = currency &lt; 100\n    )\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    0.1\n50.0\n    2.2\n17.9\n    33.3\n1.4\n    444.4\n65,100.0\n    5,550.0\n1,325.8\n    NA\n13.3\n    777,000.0\nNA\n    8,880,000.0\n0.4\n  \n  \n  \n\n\n\n\nUse sp500 to create a gt table. Color entire rows of cells based on values in a particular column.\n\nsp500 |&gt;\n  dplyr::filter(\n    date &gt;= \"2015-12-01\" &\n    date &lt;= \"2015-12-15\"\n  ) |&gt;\n  dplyr::select(-c(adj_close, volume)) |&gt;\n  gt() |&gt;\n  tab_style(\n    style = cell_fill(color = \"lightgreen\"),\n    locations = cells_body(rows = close &gt; open)\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"tomato\"),\n      cell_text(color = \"white\")\n      ),\n    locations = cells_body(rows = open &gt; close)\n  )\n\n\n\n\n\n  \n    \n    \n      date\n      open\n      high\n      low\n      close\n    \n  \n  \n    2015-12-15\n2025.55\n2053.87\n2025.55\n2043.41\n    2015-12-14\n2013.37\n2022.92\n1993.26\n2021.94\n    2015-12-11\n2047.27\n2047.27\n2008.80\n2012.37\n    2015-12-10\n2047.93\n2067.65\n2045.67\n2052.23\n    2015-12-09\n2061.17\n2080.33\n2036.53\n2047.62\n    2015-12-08\n2073.39\n2073.85\n2052.32\n2063.59\n    2015-12-07\n2090.42\n2090.42\n2066.78\n2077.07\n    2015-12-04\n2051.24\n2093.84\n2051.24\n2091.69\n    2015-12-03\n2080.71\n2085.00\n2042.35\n2049.62\n    2015-12-02\n2101.71\n2104.27\n2077.11\n2079.51\n    2015-12-01\n2082.93\n2103.37\n2082.93\n2102.63\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_options(\n  data,\n  container.width = NULL,\n  container.height = NULL,\n  container.overflow.x = NULL,\n  container.overflow.y = NULL,\n  table.width = NULL,\n  table.layout = NULL,\n  &lt;many more options&gt;\n  page.header.height = NULL,\n  page.footer.height = NULL,\n  quarto.use_bootstrap = NULL,\n  quarto.disable_processing = NULL\n)\nWith tab_options() we can modify the global options for a gt table. These options are named by the components, the sub-components, and the element that can adjusted. This function has a very large set of arguments and many aspects of the table can be adjusted. Later on, we’ll take a look at some shortcuts to common options with the opt_*() functions.\n\n\nUse exibble to create a gt table with all the main parts added; we can use this going forward to demo some tab_options().\n\ntab_1 &lt;- \n  exibble |&gt;\n  dplyr::select(\n    -c(fctr, date, time, datetime)\n  ) |&gt;\n  gt(\n    rowname_col = \"row\",\n    groupname_col = \"group\"\n  ) |&gt;\n  tab_header(\n    title = md(\"Data listing from **exibble**\"),\n    subtitle = md(\"`exibble` is an R dataset\")\n  ) |&gt;\n  fmt_number(columns = num) |&gt;\n  fmt_currency(columns = currency) |&gt;\n  tab_footnote(\n    footnote = \"Using commas for separators.\",\n    locations = cells_body(\n      columns = num,\n      rows = num &gt; 1000\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"Using commas for separators.\",\n    locations = cells_body(\n      columns = currency,\n      rows = currency &gt; 1000\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"Alphabetical fruit.\",\n    locations = cells_column_labels(columns = char)\n  )\n\ntab_1\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nModify the table width (with table.width) to 100% (which spans the entire content width area).\n\ntab_1 |&gt;\n  tab_options(table.width = pct(100)) # pct() helper function used here\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nModify the table’s background color (with table.background.color) to be \"lightcyan\".\n\ntab_1 |&gt;\n  tab_options(table.background.color = \"lightcyan\")\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nUse letters as the glyphs for footnote references (with footnotes.marks and the letters vector).\n\ntab_1 |&gt;\n  tab_options(footnotes.marks = letters)\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      chara\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\nb $65,100.00\n    \n      grp_b\n    \n    row_5\nb 5,550.00\nNA\nb $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\nb 777,000.00\ngrapefruit\nNA\n    row_8\nb 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      a Alphabetical fruit.\n    \n    \n      b Using commas for separators.\n    \n  \n\n\n\n\nChange the padding of data rows to 5px with data_row.padding.\n\ntab_1 |&gt; \n  tab_options(data_row.padding = px(5)) # px() helper function used here\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nReduce the size of the title and the subtitle text (with heading.title.font.size and heading.subtitle.font.size).\n\ntab_1 |&gt;\n  tab_options(\n    heading.title.font.size = \"small\",\n    heading.subtitle.font.size = \"small\"\n  )\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\n\n\n\n\n\n\nA header can be added to a gt table with tab_header(); use md() to style title/subtitle.\nSource notes can be added to the footer of a table with tab_source_note().\nSpanner column labels can be placed above selected column labels with tab_spanner().\nIf you have a stub and want a label above it, use tab_stubhead().\nFootnotes can be placed in specific cells (with help from the cells_*() functions) using tab_footnote().\nThe tab_style() function helps to style specified cells; use both the cells_*() and cell_*() functions for targeting and style specification.\nTons of options that affect the entire table (i.e., not targeted) can be used with tab_options()."
  },
  {
    "objectID": "modify.html#intro",
    "href": "modify.html#intro",
    "title": "Modify",
    "section": "",
    "text": "A gt table can contain a few useful parts for conveying additional information. These include a header (with a titles and subtitle), a footer (with footnotes and source notes), and additional areas for labels (row group labels, column spanner labels, the stubhead label). We can modify the look of table parts more generally with tab_options() and perform styling on targeted table locations with tab_style().\n\n\n\n\ntab_header()\ntab_stubhead()\ntab_spanner()\ntab_row_group()\ntab_source_note()\ntab_footnote()\ntab_style()\ntab_options()\n\nSome of the helper functions for selecting columns and rows:\n\ncontains()\nmatches()\nstarts_with()\nends_with()\neverything()\n\nHelpers for transforming text:\n\nmd()\nhtml()\n\nHelpers for targeting locations (for tab_footnote() and tab_style()):\n\ncells_title()\ncells_stubhead()\ncells_column_spanners()\ncells_column_labels()\ncells_row_groups()\ncells_stub()\ncells_body()\ncells_summary()\ncells_grand_summary()\n\nHelpers for defining styles (only for tab_style()):\n\ncell_text()\ncell_fill()\ncell_borders()\n\n\n\n\n\ntab_header(\n  data,\n  title,\n  subtitle = NULL,\n  preheader = NULL\n)\nWe can add a table header to the gt table with a title and optionally a subtitle. A table header is an optional table part that is positioned above the column labels. We have the flexibility to use Markdown or HTML formatting for the header’s title and subtitle (with md() or html()).\n\n\nUse gtcars to create a gt table; add a header part to contain a title and subtitle.\n\ngtcars |&gt;\n  dplyr::select(mfr, model, msrp) |&gt;\n  dplyr::slice(1:5) |&gt;\n  gt() |&gt;\n  tab_header(\n    title = md(\"Data listing from **gtcars**\"),\n    subtitle = md(\"`gtcars` is an R dataset\")\n  )\n\n\n\n\n\n  \n    \n      Data listing from gtcars\n    \n    \n      gtcars is an R dataset\n    \n    \n      mfr\n      model\n      msrp\n    \n  \n  \n    Ford\nGT\n447000\n    Ferrari\n458 Speciale\n291744\n    Ferrari\n458 Spider\n263553\n    Ferrari\n458 Italia\n233509\n    Ferrari\n488 GTB\n245400\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_stubhead(\n  data,\n  label\n)\nAdd a label to the stubhead of a gt table. The stubhead is the lone element that is positioned left of the column labels, and above the stub. We have the flexibility to use Markdown formatting for the stubhead label with md(). Furthermore, if the table is intended for HTML output, we can use HTML for the stubhead label (with html()).\n\n\nUse gtcars to create a gt table. Add a stubhead label to describe what is in the stub.\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:5) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_stubhead(label = \"car\")\n\n\n\n\n\n  \n    \n    \n      car\n      year\n      hp\n      trq\n    \n  \n  \n    GT\n2017\n647\n550\n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    488 GTB\n2016\n661\n561\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_spanner(\n  data,\n  label,\n  columns = NULL,\n  spanners = NULL,\n  level = NULL,\n  id = label,\n  gather = TRUE,\n  replace = FALSE\n)\nSet a spanner column label by mapping it to columns already in the table. This label is placed above one or more column labels, spanning the width of those columns and column labels.\nWith columns we can use column names in double quotes (\"&lt;column&gt;\"), in c() (c(&lt;column&gt;)), or, we can use the following tidyselect expressions:\n\ncontains(): contains a literal string\nmatches(): matches a regular expression\nstarts_with(): starts with a prefix\nends_with(): ends with a suffix\neverything(): selects all columns\n\n\n\nLet’s use the gtcars table, but cut it down to size first:\n\ngtcars_small &lt;- \n  gtcars |&gt;\n  dplyr::select(\n    -mfr, -trim, bdy_style, drivetrain,\n    -drivetrain, -trsmn, -ctry_origin\n  ) |&gt;\n  dplyr::slice(1:8)\n\ngtcars_small\n\n# A tibble: 8 × 10\n  model         year bdy_style      hp hp_rpm   trq trq_rpm mpg_c mpg_h   msrp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 GT            2017 coupe         647   6250   550    5900    11    18 447000\n2 458 Speciale  2015 coupe         597   9000   398    6000    13    17 291744\n3 458 Spider    2015 convertible   562   9000   398    6000    13    17 263553\n4 458 Italia    2014 coupe         562   9000   398    6000    13    17 233509\n5 488 GTB       2016 coupe         661   8000   561    3000    15    22 245400\n6 California    2015 convertible   553   7500   557    4750    16    23 198973\n7 GTC4Lusso     2017 coupe         680   8250   514    5750    12    17 298000\n8 FF            2015 coupe         652   8000   504    6000    11    16 295000\n\n\nLet’s look at the table in gt so that we know where we are starting from.\n\ngtcars_small |&gt; gt(rowname_col = \"model\")\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n      msrp\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nUse gtcars to create a gt table; Group several columns related to car performance under a spanner column with the label performance.\n\ngtcars_small |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_spanner(\n    label = \"performance\",\n    columns = c(hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h)\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      \n        performance\n      \n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nWith a few tidyselect statements in c(), we can get the same columns.\n\ngtcars_small |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_spanner(\n    label = \"performance\",\n    columns = c(starts_with(\"hp\"), starts_with(\"trq\"), starts_with(\"mpg\"))\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      bdy_style\n      \n        performance\n      \n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n2017\ncoupe\n647\n6250\n550\n5900\n11\n18\n447000\n    458 Speciale\n2015\ncoupe\n597\n9000\n398\n6000\n13\n17\n291744\n    458 Spider\n2015\nconvertible\n562\n9000\n398\n6000\n13\n17\n263553\n    458 Italia\n2014\ncoupe\n562\n9000\n398\n6000\n13\n17\n233509\n    488 GTB\n2016\ncoupe\n661\n8000\n561\n3000\n15\n22\n245400\n    California\n2015\nconvertible\n553\n7500\n557\n4750\n16\n23\n198973\n    GTC4Lusso\n2017\ncoupe\n680\n8250\n514\n5750\n12\n17\n298000\n    FF\n2015\ncoupe\n652\n8000\n504\n6000\n11\n16\n295000\n  \n  \n  \n\n\n\n\nIf we relocate the \"hp\" column to the beginning (i.e., far left), the associated columns are gathered together (because gather = TRUE).\n\ngtcars_small |&gt;\n  dplyr::select(hp, everything()) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n    tab_spanner(\n    label = \"performance\",\n    columns = c(hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h)\n  )\n\n\n\n\n\n  \n    \n    \n      \n      \n        performance\n      \n      year\n      bdy_style\n      msrp\n    \n    \n      hp\n      hp_rpm\n      trq\n      trq_rpm\n      mpg_c\n      mpg_h\n    \n  \n  \n    GT\n647\n6250\n550\n5900\n11\n18\n2017\ncoupe\n447000\n    458 Speciale\n597\n9000\n398\n6000\n13\n17\n2015\ncoupe\n291744\n    458 Spider\n562\n9000\n398\n6000\n13\n17\n2015\nconvertible\n263553\n    458 Italia\n562\n9000\n398\n6000\n13\n17\n2014\ncoupe\n233509\n    488 GTB\n661\n8000\n561\n3000\n15\n22\n2016\ncoupe\n245400\n    California\n553\n7500\n557\n4750\n16\n23\n2015\nconvertible\n198973\n    GTC4Lusso\n680\n8250\n514\n5750\n12\n17\n2017\ncoupe\n298000\n    FF\n652\n8000\n504\n6000\n11\n16\n2015\ncoupe\n295000\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_row_group(\n  data,\n  label,\n  rows,\n  id = label,\n  others_label = NULL,\n  group = NULL\n)\nCreate a row group with a collection of rows. This requires specification of the rows to be included, either by supplying row labels, row indices, or through use of a select helper function like starts_with(). To modify the order of row groups, use the row_group_order() function.\n\n\nUse gtcars to create a gt table and add two row groups with the labels: numbered and NA (a group without a label associated with it)\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"numbered\",\n    rows = matches(\"^[0-9]\")\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      numbered\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    488 GTB\n2016\n661\n561\n    \n      \n    \n    GT\n2017\n647\n550\n    California\n2015\n553\n557\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n  \n  \n  \n\n\n\n\nUse gtcars to create a gt table. Add two row groups with the labels powerful and more powerful: the distinction is having hp lesser or greater than 600.\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"powerful\",\n    rows = hp &lt;= 600\n  ) |&gt;\n  tab_row_group(\n    label = \"more powerful\",\n    rows = hp &gt; 600\n  )\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      more powerful\n    \n    GT\n2017\n647\n550\n    488 GTB\n2016\n661\n561\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n    \n      powerful\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    California\n2015\n553\n557\n  \n  \n  \n\n\n\n\nIf the order is not what you want, you can change the calling order of the tab_row_group() statements, or, use row_group_order() afterward:\n\ngtcars |&gt;\n  dplyr::select(model, year, hp, trq) |&gt;\n  dplyr::slice(1:8) |&gt;\n  gt(rowname_col = \"model\") |&gt;\n  tab_row_group(\n    label = \"powerful\",\n    rows = hp &lt;= 600\n  ) |&gt;\n  tab_row_group(\n    label = md(\"**more powerful**\"),\n    rows = hp &gt; 600,\n    id = \"more_powerful\"\n  ) |&gt;\n  row_group_order(groups = c(\"powerful\", \"more_powerful\"))\n\n\n\n\n\n  \n    \n    \n      \n      year\n      hp\n      trq\n    \n  \n  \n    \n      powerful\n    \n    458 Speciale\n2015\n597\n398\n    458 Spider\n2015\n562\n398\n    458 Italia\n2014\n562\n398\n    California\n2015\n553\n557\n    \n      more powerful\n    \n    GT\n2017\n647\n550\n    488 GTB\n2016\n661\n561\n    GTC4Lusso\n2017\n680\n514\n    FF\n2015\n652\n504\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_source_note(\n  data,\n  source_note\n)\nWe can add a source note to the footer part of any gt table. A source note is useful for citing the data included in the table. Several can be added, simply use multiple calls of tab_source_note() and they will be inserted in the order provided. We can use Markdown formatting for the note, or, if the table is intended for HTML output, we can include HTML formatting.\n\n\nUse exibble to create a gt table. Add a source note to the table footer that cites the data source.\n\nexibble |&gt;\n  gt() |&gt;\n  tab_source_note(\n    source_note = \"The `exibble` dataset is available in the **gt** package.\"\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n    \n      The `exibble` dataset is available in the **gt** package.\n    \n  \n  \n\n\n\n\n\n\n\n\n\ntab_footnote(\n  data,\n  footnote,\n  locations = NULL,\n  placement = c(\"auto\", \"right\", \"left\")\n)\nThe tab_footnote() function can make it a painless process to add a footnote to a gt table. There are two components to a footnote: (1) a footnote mark that is attached to the targeted cell text, and (2) the footnote text (that starts with the corresponding footnote mark) that is placed in the table’s footer area.\nEach call of tab_footnote() will add a different note, and one or more cells can be targeted via the location helper (use in locations):\n\ncells_title() - target the table title or subtitle\ncells_stubhead() - target the table stubhead cell\ncells_column_spanners() - target the column spanners\ncells_column_labels() - target the column labels\ncells_row_groups() - target row groups\ncells_stub() - target cells in the table stub\ncells_body() - target data cells in the table body\ncells_summary() - target group summary cells\ncells_grand_summary() - target cells in a grand summary\n\nAdditionally, we can enclose several cells_*() calls within a list() if we wish to link the footnote text to different types of locations (e.g., body cells, row group labels, the table title, etc.).\n\n\nUse exibble to create a gt table and then add a footnote to the fctr column label explaining what the short form means (fctr = ‘factor’).\n\nexibble |&gt;\n  gt() |&gt;\n  tab_footnote(\n    footnote = \"This is a factor column.\",\n    locations = cells_column_labels(columns = fctr)\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      char\n      fctr1\n      date\n      time\n      datetime\n      currency\n      row\n      group\n    \n  \n  \n    1.111e-01\napricot\none\n2015-01-15\n13:35\n2018-01-01 02:22\n49.950\nrow_1\ngrp_a\n    2.222e+00\nbanana\ntwo\n2015-02-15\n14:40\n2018-02-02 14:33\n17.950\nrow_2\ngrp_a\n    3.333e+01\ncoconut\nthree\n2015-03-15\n15:45\n2018-03-03 03:44\n1.390\nrow_3\ngrp_a\n    4.444e+02\ndurian\nfour\n2015-04-15\n16:50\n2018-04-04 15:55\n65100.000\nrow_4\ngrp_a\n    5.550e+03\nNA\nfive\n2015-05-15\n17:55\n2018-05-05 04:00\n1325.810\nrow_5\ngrp_b\n    NA\nfig\nsix\n2015-06-15\nNA\n2018-06-06 16:11\n13.255\nrow_6\ngrp_b\n    7.770e+05\ngrapefruit\nseven\nNA\n19:10\n2018-07-07 05:22\nNA\nrow_7\ngrp_b\n    8.880e+06\nhoneydew\neight\n2015-08-15\n20:20\nNA\n0.440\nrow_8\ngrp_b\n  \n  \n  \n    \n      1 This is a factor column.\n    \n  \n\n\n\n\n\n\n\n\n\ntab_style(\n  data,\n  style,\n  locations\n)\nWith the tab_style() function we can target specific cells and apply styles to them.\nThis is done with the help of the following functions:\n\ncell_text()\ncell_fill()\ncell_borders()\n\nFor locations we use the cells_*() functions, just like in the tab_footnote() function. In the example below, we’ll take things a step further with the cells_body() function and use a conditional statement in rows to target cells based on data.\n\n\nChange the font of all body cells in the exibble table to Times New Roman. By default, using cells_body() without any arguments means all table body cells are targeted.\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  tab_style(\n    style = cell_text(font = \"Times New Roman\"),\n    locations = cells_body()\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    1.111e-01\n49.950\n    2.222e+00\n17.950\n    3.333e+01\n1.390\n    4.444e+02\n65100.000\n    5.550e+03\n1325.810\n    NA\n13.255\n    7.770e+05\nNA\n    8.880e+06\n0.440\n  \n  \n  \n\n\n\n\nUse a font from the Google Fonts service by using the google_font() function. Recommendations on some Google fonts can be found by using info_google_fonts().\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  fmt_currency(columns = currency, currency = \"EUR\") |&gt;\n  tab_style(\n    style = cell_text(font = google_font(\"IBM Plex Sans\"), weight = 500),\n    locations = cells_body()\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    1.111e-01\n€49.95\n    2.222e+00\n€17.95\n    3.333e+01\n€1.39\n    4.444e+02\n€65,100.00\n    5.550e+03\n€1,325.81\n    NA\n€13.26\n    7.770e+05\nNA\n    8.880e+06\n€0.44\n  \n  \n  \n\n\n\n\nUse exibble to create a gt table. Add styles that are to be applied to data cells that satisfy a condition (using tab_style()).\n\nexibble |&gt;\n  dplyr::select(num, currency) |&gt;\n  gt() |&gt;\n  fmt_number(\n    columns = c(num, currency),\n    decimals = 1\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"cyan\"),\n      cell_text(weight = \"bold\")\n      ),\n    locations = cells_body(\n      columns = num,\n      rows = num &gt;= 5000\n    )\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"#F9E3D6\"),\n      cell_text(style = \"italic\")\n      ),\n    locations = cells_body(\n      columns = currency,\n      rows = currency &lt; 100\n    )\n  )\n\n\n\n\n\n  \n    \n    \n      num\n      currency\n    \n  \n  \n    0.1\n50.0\n    2.2\n17.9\n    33.3\n1.4\n    444.4\n65,100.0\n    5,550.0\n1,325.8\n    NA\n13.3\n    777,000.0\nNA\n    8,880,000.0\n0.4\n  \n  \n  \n\n\n\n\nUse sp500 to create a gt table. Color entire rows of cells based on values in a particular column.\n\nsp500 |&gt;\n  dplyr::filter(\n    date &gt;= \"2015-12-01\" &\n    date &lt;= \"2015-12-15\"\n  ) |&gt;\n  dplyr::select(-c(adj_close, volume)) |&gt;\n  gt() |&gt;\n  tab_style(\n    style = cell_fill(color = \"lightgreen\"),\n    locations = cells_body(rows = close &gt; open)\n  ) |&gt;\n  tab_style(\n    style = list(\n      cell_fill(color = \"tomato\"),\n      cell_text(color = \"white\")\n      ),\n    locations = cells_body(rows = open &gt; close)\n  )\n\n\n\n\n\n  \n    \n    \n      date\n      open\n      high\n      low\n      close\n    \n  \n  \n    2015-12-15\n2025.55\n2053.87\n2025.55\n2043.41\n    2015-12-14\n2013.37\n2022.92\n1993.26\n2021.94\n    2015-12-11\n2047.27\n2047.27\n2008.80\n2012.37\n    2015-12-10\n2047.93\n2067.65\n2045.67\n2052.23\n    2015-12-09\n2061.17\n2080.33\n2036.53\n2047.62\n    2015-12-08\n2073.39\n2073.85\n2052.32\n2063.59\n    2015-12-07\n2090.42\n2090.42\n2066.78\n2077.07\n    2015-12-04\n2051.24\n2093.84\n2051.24\n2091.69\n    2015-12-03\n2080.71\n2085.00\n2042.35\n2049.62\n    2015-12-02\n2101.71\n2104.27\n2077.11\n2079.51\n    2015-12-01\n2082.93\n2103.37\n2082.93\n2102.63\n  \n  \n  \n\n\n\n\n\n\n\n\n\ntab_options(\n  data,\n  container.width = NULL,\n  container.height = NULL,\n  container.overflow.x = NULL,\n  container.overflow.y = NULL,\n  table.width = NULL,\n  table.layout = NULL,\n  &lt;many more options&gt;\n  page.header.height = NULL,\n  page.footer.height = NULL,\n  quarto.use_bootstrap = NULL,\n  quarto.disable_processing = NULL\n)\nWith tab_options() we can modify the global options for a gt table. These options are named by the components, the sub-components, and the element that can adjusted. This function has a very large set of arguments and many aspects of the table can be adjusted. Later on, we’ll take a look at some shortcuts to common options with the opt_*() functions.\n\n\nUse exibble to create a gt table with all the main parts added; we can use this going forward to demo some tab_options().\n\ntab_1 &lt;- \n  exibble |&gt;\n  dplyr::select(\n    -c(fctr, date, time, datetime)\n  ) |&gt;\n  gt(\n    rowname_col = \"row\",\n    groupname_col = \"group\"\n  ) |&gt;\n  tab_header(\n    title = md(\"Data listing from **exibble**\"),\n    subtitle = md(\"`exibble` is an R dataset\")\n  ) |&gt;\n  fmt_number(columns = num) |&gt;\n  fmt_currency(columns = currency) |&gt;\n  tab_footnote(\n    footnote = \"Using commas for separators.\",\n    locations = cells_body(\n      columns = num,\n      rows = num &gt; 1000\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"Using commas for separators.\",\n    locations = cells_body(\n      columns = currency,\n      rows = currency &gt; 1000\n    )\n  ) |&gt;\n  tab_footnote(\n    footnote = \"Alphabetical fruit.\",\n    locations = cells_column_labels(columns = char)\n  )\n\ntab_1\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nModify the table width (with table.width) to 100% (which spans the entire content width area).\n\ntab_1 |&gt;\n  tab_options(table.width = pct(100)) # pct() helper function used here\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nModify the table’s background color (with table.background.color) to be \"lightcyan\".\n\ntab_1 |&gt;\n  tab_options(table.background.color = \"lightcyan\")\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nUse letters as the glyphs for footnote references (with footnotes.marks and the letters vector).\n\ntab_1 |&gt;\n  tab_options(footnotes.marks = letters)\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      chara\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\nb $65,100.00\n    \n      grp_b\n    \n    row_5\nb 5,550.00\nNA\nb $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\nb 777,000.00\ngrapefruit\nNA\n    row_8\nb 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      a Alphabetical fruit.\n    \n    \n      b Using commas for separators.\n    \n  \n\n\n\n\nChange the padding of data rows to 5px with data_row.padding.\n\ntab_1 |&gt; \n  tab_options(data_row.padding = px(5)) # px() helper function used here\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\nReduce the size of the title and the subtitle text (with heading.title.font.size and heading.subtitle.font.size).\n\ntab_1 |&gt;\n  tab_options(\n    heading.title.font.size = \"small\",\n    heading.subtitle.font.size = \"small\"\n  )\n\n\n\n\n\n  \n    \n      Data listing from exibble\n    \n    \n      exibble is an R dataset\n    \n    \n      \n      num\n      char1\n      currency\n    \n  \n  \n    \n      grp_a\n    \n    row_1\n0.11\napricot\n$49.95\n    row_2\n2.22\nbanana\n$17.95\n    row_3\n33.33\ncoconut\n$1.39\n    row_4\n444.40\ndurian\n2 $65,100.00\n    \n      grp_b\n    \n    row_5\n2 5,550.00\nNA\n2 $1,325.81\n    row_6\nNA\nfig\n$13.26\n    row_7\n2 777,000.00\ngrapefruit\nNA\n    row_8\n2 8,880,000.00\nhoneydew\n$0.44\n  \n  \n  \n    \n      1 Alphabetical fruit.\n    \n    \n      2 Using commas for separators.\n    \n  \n\n\n\n\n\n\n\n\n\n\nA header can be added to a gt table with tab_header(); use md() to style title/subtitle.\nSource notes can be added to the footer of a table with tab_source_note().\nSpanner column labels can be placed above selected column labels with tab_spanner().\nIf you have a stub and want a label above it, use tab_stubhead().\nFootnotes can be placed in specific cells (with help from the cells_*() functions) using tab_footnote().\nThe tab_style() function helps to style specified cells; use both the cells_*() and cell_*() functions for targeting and style specification.\nTons of options that affect the entire table (i.e., not targeted) can be used with tab_options()."
  },
  {
    "objectID": "about.html#about-the-workshop",
    "href": "about.html#about-the-workshop",
    "title": "About",
    "section": "",
    "text": "Unlock the power of data analysis and visualization with our comprehensive R Workshop! Join us to learn R programming, data manipulation, and visualization techniques. Discover how to effectively analyze data, create insightful visualizations, and gain valuable insights for your research. Our hands-on approach and expert instructors will guide you through practical exercises and real-world examples, ensuring you leave with practical skills to harness R’s capabilities.\n\nLocation: Department of Statistics, CUSAT\nResource: Dr. Rasin RS, Mahesh D & Rakesh Poduval"
  }
]